/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "proxy.h"
#include "proxy_data.h"
#include "lfuLogic.h"
#include "fifoLogic.h"
#include "randLogic.h"
#include "largestSizeLogic.h"
#include "lruLogic.h"
#include "proxy_header.h"
#include "cache_utilities.h"
#include "heap_utilities.h"
#include <curl/curl.h>

#define LRU 1
#define LFU 2
#define FIFO 3
#define RAND 4
#define LARGESTSIZE 5
//#define NOCACHE

struct wd_in {
    size_t size;
    size_t len;
    char *data;
};

CacheBlockPtr cacheEntries[MAXSIZE_HASHTABLE];
HeapBlockPtr currentHeap[MAXSIZE_CACHE];
int isInitialized = 0;
unsigned long currentCacheSize;
CompareHeapNodes currentStrategyComparison;
LinkAndInitialize currentStrategyHeapInitialization;
UpdateMetaData currentStrategyUpdateMetaData;
GetNewHeapNode currentStrategyGetHeapNode;
int replacementAlgo = 0;
FILE *currOutPutFile;
unsigned long MaxCacheMemSize = 0;
unsigned long totalConsumedSize = 0;
static size_t write_data(void *buffer, size_t size,
        size_t nmemb, void *userp) {
    struct wd_in *wdi = userp;

    //while (wdi->len + (size * nmemb) >= wdi->size) {
    /* check for realloc failing in real code. */
    wdi->size = wdi->len + (size * nmemb) + 1;
    wdi->data = realloc(wdi->data, wdi->size);
    // wdi->size *= 2;
    //}
    //printf("Called with size:%d\n",size);

    memcpy(wdi->data + wdi->len, buffer, size * nmemb);
    wdi->len += size*nmemb;
    (wdi->data)[wdi->len] = 0;
    return size * nmemb;
}

void initializeGlobalData(char *initString) {
    memset(cacheEntries, 0, MAXSIZE_HASHTABLE * sizeof (CacheBlockPtr));
    memset(currentHeap, 0, MAXSIZE_CACHE * sizeof (HeapBlockPtr));
    currentCacheSize = 0;
    int currentReplacementAlgo = 0;
    char outputFileName[1024];
    char *userString = "";
    printf("Got:%s\n", initString);
    if (initString) {
        char *savePtr;
        char *temp;
        temp = strtok_r(initString, ",", &savePtr);
        printf("First Token:%s\n", temp);
        if (strstr(temp, "init")) {
            temp = strtok_r(NULL, ",", &savePtr);
            printf("Second Token:%s\n", temp);
            if (temp) {
                userString = temp;
            }

            temp = strtok_r(NULL, ",", &savePtr);
            printf("Third Token:%s\n", temp);
            MaxCacheMemSize = atol(temp);
            temp = strtok_r(NULL, ",", &savePtr);
            printf("Fourth Token:%s\n", temp);
            currentReplacementAlgo = atoi(temp);
        }
    }

    switch (currentReplacementAlgo) {
        case LRU:
            sprintf(outputFileName, "LRU_CacheSize%ld_%s.txt", MaxCacheMemSize, userString);
            currentStrategyComparison = &compareLRUHeapNode;
            currentStrategyHeapInitialization = &linkLRUCacheMetaData;
            currentStrategyUpdateMetaData = &updateLRUMetaData;
            currentStrategyGetHeapNode = &getNewLRUHeapNode;
            break;
        case LFU:
            sprintf(outputFileName, "LFU_CacheSize%ld_%s.txt", MaxCacheMemSize, userString);
            currentStrategyComparison = &compareLFUHeapNode;
            currentStrategyHeapInitialization = &linkLFUCacheMetaData;
            currentStrategyUpdateMetaData = &updateLFUMetaData;
            currentStrategyGetHeapNode = &getNewLFUHeapNode;
            break;
        case RAND:
            sprintf(outputFileName, "RAND_CacheSize%ld_%s.txt", MaxCacheMemSize, userString);
            currentStrategyComparison = &compareRANDHeapNode;
            currentStrategyHeapInitialization = &linkRANDCacheMetaData;
            currentStrategyUpdateMetaData = &updateRANDMetaData;
            currentStrategyGetHeapNode = &getNewRANDHeapNode;
            break;
        case FIFO:
            sprintf(outputFileName, "FIFO_CacheSize%ld_%s.txt", MaxCacheMemSize, userString);
            currentStrategyComparison = &compareFIFOHeapNode;
            currentStrategyHeapInitialization = &linkFIFOCacheMetaData;
            currentStrategyUpdateMetaData = &updateFIFOMetaData;
            currentStrategyGetHeapNode = &getNewFIFOHeapNode;
            break;
        case LARGESTSIZE:
            sprintf(outputFileName, "LARGESTSIZE_CacheSize%ld_%s.txt", MaxCacheMemSize, userString);
            currentStrategyComparison = &compareLargestSizeHeapNode;
            currentStrategyHeapInitialization = &linkLargestSizeCacheMetaData;
            currentStrategyUpdateMetaData = &updateLargestSizeMetaData;
            currentStrategyGetHeapNode = &getNewLargestSizeHeapNode;
            break;
        default:
            fprintf(stderr, "Expecting initialization string: init,userString,MaxCacheSizeInBytes,1-5\n");
            exit(-1);
            break;
    }
    currOutPutFile = fopen(outputFileName, "w");
    fprintf(currOutPutFile, "UserString:%s\n", userString);
    replacementAlgo = currentReplacementAlgo;
    isInitialized = 1;
}

bool_t
proxy_fetch_1_svc(char **argp, webpageResponse *result, struct svc_req *rqstp) {
    static bool_t retval = 1;

    CacheBlockPtr targetCacheBlock = NULL;

#ifndef NOCACHE

    if (!isInitialized) {
        initializeGlobalData(*argp);
        srand(time(NULL));
        return retval;
    }
    if (!strcmp(*argp, "exit")) {
        printf("Exit Command Received. Exiting\n");
        fprintf(currOutPutFile, "Exit Command Received. Exiting\n");
        fprintf(currOutPutFile, "Total Size:%ld\n", totalConsumedSize);
        fprintf(currOutPutFile, "Free Size:%ld\n", MaxCacheMemSize-totalConsumedSize);
        fflush(stdout);
        fflush(currOutPutFile);
        fclose(currOutPutFile);
        exit(0);
    }
    /*
     * insert server code here
     */
    //printf("Got :%s\n", *argp);
    //printf("size of cache:%d\n", currentCacheSize);
    targetCacheBlock = getCacheBlock(*argp, cacheEntries);
    //printf("Got Cache Block:%x\n", targetCacheBlock);
    if (targetCacheBlock) {
        fprintf(currOutPutFile, "Cache Hit for:%s\n", *argp);
        if (replacementAlgo != LARGESTSIZE) {
            currentStrategyUpdateMetaData(targetCacheBlock);
        }

    } else {

        CURL *curl;
        CURLcode res;
        struct wd_in wdi;

        memset(&wdi, 0, sizeof (wdi));
        //wdi.data = &(targetCacheBlock->data);
        /* Get a curl handle.  Each thread will need a unique handle. */
        curl = curl_easy_init();

        if (NULL != curl) {
            wdi.size = 1024;
            /* Check for malloc failure in real code. */
            wdi.data = malloc(wdi.size);

            /* Set the URL for the operation. */
            curl_easy_setopt(curl, CURLOPT_URL, *argp);

            curl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION, 1);

            curl_easy_setopt(curl, CURLOPT_MAXREDIRS, -1);

            /* "write_data" function to call with returned data. */
            curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, write_data);
            curl_easy_setopt(curl, CURLOPT_SSL_VERIFYPEER, 0);
            //curl_easy_setopt(curl, CURLOPT_SSL_VERIFYHOST, 1);
            curl_easy_setopt(curl, CURLOPT_USERAGENT, "curl/7.22.0 (x86_64-pc-linux-gnu) libcurl/7.22.0 OpenSSL/1.0.1 zlib/1.2.3.4 libidn/1.23 librtmp/2.3");
            curl_easy_setopt(curl, CURLOPT_AUTOREFERER, 1);
            //curl_easy_setopt(curl,CURLOPT_VERBOSE,1);

            /* userp parameter passed to write_data. */
            curl_easy_setopt(curl, CURLOPT_WRITEDATA, &wdi);

            /* Actually perform the query. */
            //printf("Trying to do web query\n");
            res = curl_easy_perform(curl);
            //printf("Returned:%d\n",res);
            
            //printf("Web Query finished\n");
            //printf("Size:%d\n", targetCacheBlock->size);
            //printf("Pointer:%x,%x\n", *(wdi.data), targetCacheBlock->data);
            curl_easy_cleanup(curl);

            CacheBlockPtr newNode = NULL;
           
            if (totalConsumedSize + wdi.len <= MaxCacheMemSize) {
                fprintf(currOutPutFile, "New Cache Block for:%s, size:%lu, freeSpace:%lu\n", *argp, wdi.len, MaxCacheMemSize - totalConsumedSize);
                //fprintf(currOutPutFile, "%s,%lu\n", *argp, wdi.len);
            }
            int noOfEvictions;
            noOfEvictions = 0;
            while (totalConsumedSize + wdi.len > MaxCacheMemSize) {
                //Replace a cache entry
                HeapBlockPtr victimHeapNode = getTopHeapNode(currentHeap, currentCacheSize, currentStrategyComparison);
                CacheBlockPtr victimCacheBlock = getCorrespondingCacheBlock(victimHeapNode);
                totalConsumedSize -= victimCacheBlock->size;
                //fprintf(currOutPutFile, "Evicted Cache Block of: %s,for:%s, size:%lu, freeSpace:%lu\n", victimCacheBlock->url, *argp, wdi.len, MaxCacheMemSize - totalConsumedSize);

                freeHeapNodeContents(victimHeapNode);
                //printf("To Remove:%x\n", victimCacheBlock);
                //printf("LFU Count:%d\n", *((int*) victimHeapNode->key));
                unmapCacheBlock(victimCacheBlock, cacheEntries);
                freeCacheBlock(victimCacheBlock);
                currentCacheSize--;
                noOfEvictions++;
            }
            if(noOfEvictions){
                fprintf(currOutPutFile,"Evicted %d Cache Blocks for:%s\n",noOfEvictions,*argp);
            }
            newNode = getNewCacheBlock(*argp);
            //printf("Inserting new Cache Block:%x\n", newNode);
            if (newNode) {
                newNode->data = wdi.data;
                newNode->size = wdi.len;
                HeapBlockPtr currentHeapBlock = currentStrategyGetHeapNode();
                currentStrategyHeapInitialization(newNode, currentHeapBlock);
                if (replacementAlgo == LARGESTSIZE) {
                    currentStrategyUpdateMetaData(newNode);
                }
                insertIntoHeap(currentHeapBlock, currentHeap, currentCacheSize, currentStrategyComparison);
                insertIntoHashMap(newNode, cacheEntries);
                currentCacheSize++;
                totalConsumedSize += wdi.len;
            }
            targetCacheBlock = newNode;

        } else {
            fprintf(stderr, "Error: could not get CURL handle.\n");
            exit(EXIT_FAILURE);
        }



    }
    heapify(currentStrategyComparison, currentHeap, currentCacheSize);

    result->webPageContents = targetCacheBlock->data;

#endif


#ifdef NOCACHE
    CURL *curl;
    CURLcode res;
    struct wd_in wdi;
    //targetCacheBlock = getNewCacheBlock(*argp);
    memset(&wdi, 0, sizeof (wdi));
    //wdi.data = &(targetCacheBlock->data);
    /* Get a curl handle.  Each thread will need a unique handle. */
    curl = curl_easy_init();

    if (NULL != curl) {
        wdi.size = 1024;
        /* Check for malloc failure in real code. */
        wdi.data = malloc(wdi.size);

        /* Set the URL for the operation. */
        curl_easy_setopt(curl, CURLOPT_URL, *argp);

        curl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION, 1);
        curl_easy_setopt(curl, CURLOPT_MAXREDIRS, -1);

        /* "write_data" function to call with returned data. */
        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, write_data);
        curl_easy_setopt(curl, CURLOPT_SSL_VERIFYPEER, 0);
        curl_easy_setopt(curl, CURLOPT_USERAGENT, "curl/7.22.0 (x86_64-pc-linux-gnu) libcurl/7.22.0 OpenSSL/1.0.1 zlib/1.2.3.4 libidn/1.23 librtmp/2.3");
        curl_easy_setopt(curl, CURLOPT_AUTOREFERER, 1);

        /* userp parameter passed to write_data. */
        curl_easy_setopt(curl, CURLOPT_WRITEDATA, &wdi);

        /* Actually perform the query. */
        //printf("Trying to do web query\n");
        res = curl_easy_perform(curl);
        // printf("Web Query finished\n");
        // printf("Size:%d\n", targetCacheBlock->size);
        //printf("Pointer:%x,%x\n", *(wdi.data), targetCacheBlock->data);
        /* Check the return value and do whatever. */
        result->webPageContents = wdi.data;//targetCacheBlock->data;
        /* Clean up after ourselves. */
        curl_easy_cleanup(curl);
    } else {
        fprintf(stderr, "Error: could not get CURL handle.\n");
        exit(EXIT_FAILURE);
    }
#endif

    return retval;
}

int
proxy_fetch_prog_1_freeresult(SVCXPRT *transp, xdrproc_t xdr_result, caddr_t result) {
#ifdef NOCACHE
    xdr_free(xdr_result, result);
#endif

    /*
     * Insert additional freeing code here, if needed
     */

    return 1;
}
